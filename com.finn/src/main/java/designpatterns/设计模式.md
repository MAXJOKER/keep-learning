***模式*** 是在某情境下，针对某问题的某种解决方案。

### 学习设计模式的意义

设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。正确使用设计模式具有以下优点。

* 可以提高程序员的思维能力、编程能力和设计能力。
* 使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。
* 使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。

### 软件设计模式的基本要素

软件设计模式使人们可以更加简单方便地复用成功的设计和体系结构，它通常包含以下几个基本要素：
模式名称、别名、动机、问题、解决方案、效果、结构、模式角色、合作关系、实现方法、适用性、已知应用、例程、模式扩展和相关模式等，
其中最关键的元素包括以下 4 个主要部分。

***1、模式名称***
每一个模式都有自己的名字，通常用一两个词来描述，可以根据模式的问题、特点、解决方案、功能和效果来命名。
模式名称（PatternName）有助于我们理解和记忆该模式，也方便我们来讨论自己的设计。

***2、问题***
问题（Problem）描述了该模式的应用环境，即何时使用该模式。它解释了设计问题和问题存在的前因后果，以及必须满足的一系列先决条件。

***3、解决方案***
模式问题的解决方案（Solution）包括设计的组成成分、它们之间的相互关系及各自的职责和协作方式。因为模式就像一个模板，可应用于多种不同场合，
所以解决方案并不描述一个特定而具体的设计或实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合（类或对象的 组合）来解决这个问题。

***4、效果***
描述了模式的应用效果以及使用该模式应该权衡的问题，即模式的优缺点。主要是对时间和空间的衡量，以及该模式对系统的灵活性、扩充性、可移植性的影响，
也考虑其实现问题。显式地列出这些效果（Consequence）对理解和评价这些模式有很大的帮助。

### 模式分类

#### 根据目的来分

***创建型模式***用于描述“怎样创建对象”，涉及到将对象实例化，这类模式都提供一个方法，将客户从所需要实例化的对象中解耦，主要特点是“将对象的创建和使用分离”。
   * 单例
   * 抽象工厂
   * 工厂方法
   * 原型
   * 建造者

***行为型模式***，只要是行为型模式，都涉及到类和对象如何交互及分配职责，用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。
   * 模板方法
   * 迭代器
   * 命令
   * 观察者
   * 状态
   * 策略
   * 职责链
   * 中介者
   * 访问者
   * 备忘录
   * 解释器

***结构型模式***可以让你把类或对象组合到更大的结构中，用于描述如何将类或对象按某种布局组成更大的结构。
   * 装饰者
   * 代理
   * 适配器
   * 组合
   * 门面
   * 享元
   * 桥接

#### 根据作用范围来分

***另一种分类方式：模式所处理的是类或对象。***

***类模式***用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。

***对象模式***描述对象之间的关系，而且主要是利用组合定义。对象模式的关系通常在运行时建立，而且更加动态，更有弹性。

<html>
 <head></head>
 <body>
  <table border="1"> 
   <caption>
     表1GoF 的 23 种设计模式的分类表
   </caption> 
   <tbody> 
    <tr> 
     <th> 范围\目的</th> 
     <th> 创建型模式</th> 
     <th> 结构型模式</th> 
     <th> 行为型模式</th> 
    </tr> 
    <tr> 
     <td> 类模式</td> 
     <td> 工厂方法</td> 
     <td> (类）适配器</td> 
     <td> 模板方法、解释器</td> 
    </tr> 
    <tr> 
     <td colspan="1" rowspan="9"> 对象模式</td> 
     <td colspan="1" rowspan="9"> 单例<br /> 原型<br /> 抽象工厂<br /> 建造者</td> 
     <td colspan="1" rowspan="7"> 代理<br /> (对象）适配器<br /> 桥接<br /> 装饰<br /> 外观<br /> 享元<br /> 组合</td> 
     <td colspan="1" rowspan="6"> 策略<br /> 命令<br /> 职责链<br /> 状态<br /> 观察者<br /> 中介者<br /> 迭代器<br /> 访问者<br /> 备忘录</td> 
    </tr> 
   </tbody> 
  </table>
 </body>
</html>

### 23种设计模式
***装饰者(Decorator)模式*** : 包装一个对象，以提供新的行为。

***状态(State)模式***: 封装了基于状态的行为，并使用委托在行为之间切换。

***迭代器(Iterator)模式***: 在对象的集合之中游走，而不暴露集合的实现。

***外观(Facade)模式***: 简化一群类的接口。

***策略(Strategy)模式***: 封装可以互换的行为，并使用委托来决定要使用哪一个。

***代理(Proxy)模式***: 包装对象，以控制对此对象的访问。

***工厂方法(FactoryMethod)***: 由子类决定要创建的具体类是哪一个。

***适配器(Adapter)模式***: 封装对象，提供不同的接口。

***观察者(Observer)模式***: 让对象能够在状态改变时被通知。

***模板(TemplateMethod)方法***: 由子类决定如何实现一个算法中的步骤。

***组合(Composite)模式***: 客户用一致的方法处理对象集合和单个对象。

***单例(Singleton)模式***: 确保有且只有一个对象被创建。

***抽象工厂(AbstractFactory)***: 允许客户创建对象的家族，而无需指定他们的具体类。

***命令(Command)模式***: 封装请求成为对象。

***原型(Prototype)模式***: 将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。

***建造者(Builder)模式***: 将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建他们，最后构成改复杂对象。

***桥接(Bridge)模式***: 将抽象和实现分离，使他们可以独立变化。它是用组合关系代替继承关系来实现，从而减低了抽象和实现这两个可变维度的耦合。

***享元(Flyweight)模式***: 运用共享技术来有效地支持大量细粒度对象的复用。 

***职责链(Chain of Responsibility)模式***: 把请求从链中的一个对象传到下一个对象，直到请求被响应。通过这种方式去除对象之间的耦合。

***中介者(Mediator)模式***: 定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象的耦合度，使原有对象之间不必相互了解。

***访问者(Visitor)模式***: 在不改变集合元素的情况下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。

***备忘录(Memento)模式***: 在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。

***解释器(Interpreter)模式***: 提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。


