<pre>
/**
 * @recorder: maxjoker
 * @date: 2022-05-26 21:30
 * @desc: java 并发
 */
</pre>

# Java 并发 - 理论基础

## 带着大厂面试问题去学习

    多线程的出现是要解决什么问题的? 
    线程不安全是指什么? 
    举例说明 并发出现线程不安全的本质什么? (可见性，原子性和有序性)
    Java是怎么解决并发问题的? (volatile, synchronized, fian 这3个关键字，JMM和8个Happens-Before) 
    线程安全是不是非真即假? (不是) 
    线程安全有哪些实现思路? 
    如何理解并发和并行的区别?

### 为什么需要多线程？

为了合理利用CPU的高性能，平衡这三者的速度差异，计算机体系机构、操作系统、编译程序都做出了贡献，主要体现为：

    CPU增加了缓存，以均衡与内存的速度差异；（引入可见性问题）
    操作系统增加了进程、线程，以分时复用CPU，进而均衡CPU与I/O设备的速度差异；（原子性问题）
    编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。（有序性问题）

现在我们几乎所有的程序都默默地享受着这些成果，但是天下没有免费的午餐，并发程序很多诡异问题的根源也在这里。

并发编程需要解决三个核心问题

    可见性问题
    原子性问题
    有序性问题

多线程的作用

    合理利用CPU的高性能，发挥CPU的优势
    
    防止阻塞。多个线程同时运行，某个线程阻塞也不会影响系统运行

### 线程不安全case

    见同一目录下的 ThreadUnsafeTest.java 文件

### 并发出现问题的根源：并发三要素

#### 可见性：CPU缓存引起
可见性：一个线程对一个共享变量的修改，另一个线程可以立马看到

举例：
线程A修改了变量 K，但是没把修改后的K值写入 <b>主存</b> 中；
此时，线程B读取主存中的K值，读取到的K值是修改之前的值，导致造成数据不一致

也就是 线程A修改变量值后，线程B没有立即看到

#### 原子性：分时复用引起

原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。

#### 有序性：重排序引起

有序性：即程序执行的顺序按照代码的先后顺序执行

JVM在真正执行代码的时候不一定按照代码的先后顺序执行，可能会发生指令重排序（Instruction Reorder）

在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型：

    编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。 

    指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，
    处理器可以改变语句对应机器指令的执行顺序。 
    
    内存系统的重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。 


从 java 源代码到最终实际执行的指令序列，会分别经历下面三种重排序：  

    源代码 -> 1. 编译器优化排序 -> 2. 指令级并行的重排序 -> 3. 内存系统重排序 -> 最终执行的指令序列

上述的 1 属于编译器重排序，2 和 3 属于处理器重排序。这些重排序都可能会导致多线程程序出现内存可见性问题。
对于编译器，JMM 的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。
对于处理器重排序，JMM 的处理器重排序规则会要求 java 编译器在生成指令序列时，插入特定类型的内存屏障（memory barriers，intel 称之为 memory fence）指令，
通过内存屏障指令来禁止特定类型的处理器重排序（不是所有的处理器重排序都要禁止）。

<hr/>

#### Happens-Before 规则

<b>1. 单一线程原则(Single Thread rule)</b>

