### 缓存穿透 ###
<hr>
缓存穿透指的是查询的数据在数据库和redis中都没有。即查询数据时，redis中查不到，到数据库中也查不到，导致每次查询的时候都会去查一遍数据库，数据库压力增加。

解决缓存穿透的方法：

* 缓存空对象：代码维护简单，效果不好。具体做法是数据库查询结果也为空，则给对应的redis key值设置一个空的对象。redis取值时判断是否为空对象，如果是，也直接返回空，不再查询数据库。
* 布隆过滤器：代码维护复杂，效果很好。
```
布隆过滤器是一种基于概率的数据结构，主要用于判断某个元素是否在集合内，具有运行速度快，占用内存小的优点，但有一定的误识别率和删除困难的问题，只能告诉你某个元素一定不在集合内，或者某个元素可能在集合内。

特点：
1. 一个非常大的二进制位数组（数据里面只有0和1）
2. 若干个哈希函数
3. 空间效率和查询效率高
4. 不存在漏报：某个元素在集合内，肯定能判断出来
5. 可能存在误报：某个元素不在集合内，可能会被认为存在集合内
6. 不提供删除方法，维护困难
7. 值为0和1，下标是哈希值

存在误判的原因：哈希值相同，哈希碰撞
不能删除元素的原因：哈希碰撞，删了可能会导致别的数据被删掉

Google Guava 已实现
```

<br/>
<br/>

### 缓存击穿 ###
<hr>

缓存击穿是指一个key非常热点，访问量大，当key失效的瞬间，缓存失效，瞬时大量的请求直接数据库，对数据库造成巨大的压力。

缓存击穿强调的是并发，造成的原因：
* 该数据没人查询过，首次就出现大并发访问
* 数据添加到缓存，redis缓存时间过期时，有大量的访问

缓存击穿的方案就是加锁。比较普遍的做法是，当获取到的value为空时，加锁，然后从数据库中查询数据存入redis后再释放。其他线程获取锁失败，则等待重试。注意，分布式环境使用分布式锁(搞个codis锁？)，单机则用普通的锁即可（synchronized、Lock）。

<br/>
<br/>

### 缓存雪崩 ###
<hr/>

缓存雪崩是指在某一段时间内，缓存集中过期失效。此时请求直接访问数据库。

一般原因；
* redis服务挂了
* 同一时间大量key过期失效

对于缓存雪崩，一般的解决方法如下：
* 搭建高可用集群，防止单机redis宕机；
* redis key设置不同的过期时间，防止同一时间内大量key过期。