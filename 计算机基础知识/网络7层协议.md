### 网络七层协议

#### 物理层
定义物理设备标准，如网线的接口类型，光纤的接口类型，各种传输介质的传输速率等。主要作用是传输比特流（由1,0转化为电流强弱来进行传输，到达目的地后
再转化为1,0，即我们常说的数模转换和模数转换），这一层数据叫比特。

#### 数据链路层
定义了如何让格式化数据进行传输，如何控制帧在物理信道上的传输，包括数据传输错误检测和纠正，保证数据的可靠传输。

#### 网络层
通过IP进行域名寻址。

IP协议负责把数据从一台计算机通过网络发送到另一台计算机。数据被分割为多个小块，然后通过IP包发送出去。IP包的特点是按块发送，会经过多个路由，
但不保证能送达，也不保证顺序送达。

一个IP包除了包含要传输的数据外，还包含源IP地址和目标IP地址，源端口和目标端口。

#### 传输层
例如TCP，用于发送大量数据。TCP协议负责在两台计算机之间建立可靠连接，保证数据包按顺序到达。<b>TCP协议会通过握手建立连接</b>，然后对每个IP包编号，
确保对方按顺序收到，如果包丢了，就自动重发。

当TCP发出一个报文段后，它会启动一个定时器，等待目的端发确认收到这个报文段，如果没能及时收到该确认信息，则将重发这个报文段。
当TCP接收端收到发送端发来的TCP报文段时，它将发送一个确认，这个确认不是立即发送的，通常会推迟几分之一秒。

TCP将保持它首部和数据的校验和。这是一个端到端的校验和，如果收到的报文段的校验和有问题，TCP将丢掉该报文段，同时不发送确认收到的信息，
从而使发送端超时重发。最可靠的方式就是只要得不到确认，就重发数据，直到收到确认信息为止。

##### TCP三次握手
    1. 客户端发送syn包（syn=j）到服务器，并进入SYN_SEND状态，等待服务器确认；

    2. 服务器收到SYN包，必须确认客户端的SYN（ack=j+1）；同时自己也发送一个SYN包（syn=k），即SYN+ACK包；此时服务器进入SYN_RECV状态；

    3. 客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态。完成3次握手，
        开始传输数据。

##### 为什么需要3次握手？
   只有3次握手，客户端和服务器才能相互确认双向连接，实现双全工数据传输。
   
##### 四次挥手
    1. 客户端发送一个FIN（fin=i），用来关闭客户端到服务器的数据传送，客户端进入FIN_WAIT_1状态；

    2. 服务器收到FIN后，发送一个ACK（ack=i+1）个客户端，确认序号为收到序号+1，服务器进入CLOSE_WAIT状态；

    3. 服务器发送一个FIN（fin=j），用来关闭服务器到客户端的数据传送，服务器进入LAST_ACK状态；

    4. 客户端收到FIN之后，客户端进入TIME_WAIT状态，接着发送一个ACK（ack=j+1）给服务器，服务器进入CLOSED状态，完成四次挥手。

##### 为什么要四次挥手？
   服务器收到客户端的断开请求后，可以发送数据和确认码，这两部分是两两分开的，需要多一步。

##### UDP
UDP，用于发送少量数据。使用UDP协议不需要建立连接，只需要知道对方的IP地址和端口号，就可以直接发送数据包，但不确保数据能否到达。

尽管UDP是不可靠的数据传输，跟TCP比较，它的传输速度快，需要的资源少，对于不要求可靠到达的数据传输，可以使用UDP协议。

   TCP与UDP的区别

        1. TCP传输慢，UDP传输快，因为UDP不面向连接；
        2. TCP传输需要建立连接，UDP不需要；TCP传输可靠，UDP不可靠；
        3. TCP传输使用流模式，UDP传输使用数据报模式（使用DatagramePacket传输数据）；
        4. TCP保证数据的正确性，UDP可能丢包；TCP保证传输顺序，UDP不保证；
        5. TCP适合传输大量数据，UDP不会分片，不适合传输大数据；
        6. 对系统资源的要求，TCP较多，UDP较少。

#### 会话层

建立和管理应用程序之间的通信。解除或建立与别的节点的联系。
   
#### 表示层

解决不同系统平台之间通信语法问题。数据格式化，代码转换，数据加密。

#### 应用层

文件传输，电子邮件，文件服务，虚拟终端。
   
HTTP，超文本传输协议，是服务器传输超文本到本地浏览器的传送协议。
   
HTTP特点

    1. 简单快速，客户端向服务器请求时，只需传递方法和路径。
    2. 灵活，HTTP传输任意类型的数据对象，由Content-Type属性标记；
    3. 无连接，每次连接只处理一个请求，服务器处理完客户端的请求且收到客户端的应答后会立即断开连接，节约传输时间；
    4. 无状态，对事务处理没有记忆能力。如果后续请求的处理需要用到前面的信息，需要重传，传输数据量增大。
   
HTTP REQUEST

    1. 请求行：请求方法  请求URL（get方法的数据跟在url后）  HTTP协议版本
    2. 请求头部：用来说明服务器要使用的附加信息，有host，user_agnet，referer，cookie，accept，connection等信息；
    3. 空行
    4. 请求数据
        POST / HTTP 1.1
        Host:www.xxx.com
        User-Agent:Mozilla...
        Connection:Keep-Alive
        Cookie:...
        a=1&b=2
   
HTTP RESPONSE

    1. 状态行：HTTP协议版本  状态码  message；
    2. 消息报头：客户端需要使用的一些附加信息，有 Date，Server，Content-Type，Content-Length等；
    3. 空行
    4. 响应正文
        HTTP 1.1 200 OK
        Date：2019
        Server：nginx 1.9
        Content-Type：text/html;charset：UTF-8
        <html>
            ...
        </html>

HTTP状态码

    200 #请求成功，即服务器返回成功
    301 #永久重定向
    302 #临时重定向
    403 #禁止访问，一般是服务器权限拒绝
    400 #错误请求，请求中有语法问题，或不能满足请求。
    404 #服务器找不到用户请求的页面
    500 #服务器内部错误，大部分是服务器的设置或内部程序出现问题
    501 #没有将正在访问的网站设置为浏览器所请求的内容
    502 #网关问题，是代理服务器请求后端服务器时，后端服务器不可用或没有完成响应网关服务器，这通常是反向代理服务器下面的节点出问题导致的。
    503 #服务当前不可用，可能是服务器超载或停机导致的，或者是反向代理服务器后面没有可以提供服务的节点。
    504 #网关超时，一般是网关代理服务器请求后端服务器时，后端服务器没有在指定的时间内完成处理请求，多数是服务器过载导致没有在特定的时间内返回数据给前端代理服务器。
    505 #该网站不支持浏览器用于请求网页的HTTP协议版本（最为常见的是HTTP/1.1）

get和post的区别

    1. get请求，数据是跟在url后面的；而post请求的数据则是放在请求包的包体中；
    2. get请求的url长度有限制，post理论上没有数据大小的限制（服务器中其实可以设置数据提交的大小，拿php为例，php.ini的post_max_size可
        设置提交数据的大小）；
    3. post的安全性比get的安全性高，因为get的数据是暴露在url上的。