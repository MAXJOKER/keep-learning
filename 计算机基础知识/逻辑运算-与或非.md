### 逻辑运算符：与，或，非，异或

#### 1、与运算(&)

进行运算的两个数据，按二进制位进行“与”运算

规则: 同为1，结果才为1，否则为0
```
0 & 0 = 0
1 & 1 = 1
0 & 1 = 0
```

#### 2、或运算(|)

进行运算的两个数据，按二进制位进行“或”运算

规则: 只要有1，结果为1
```
1 | 0 = 1
0 | 1 = 1
1 | 1 = 1
0 | 0 = 0
```

#### 3、非运算(~)

进行运算的数据，按二进制位进行“非”运算

规则: 取反，1 取 0， 0 取 1

```
~1 = 0
~0 = 1
~(100001) = 011110
```

#### 4、异或运算(^)

进行运算的两个数据，按二进制位进行“异或”运算

规则: 两者相等为0，不等为1

```
0 ^ 0 = 0
0 ^ 1 = 1
1 ^ 0 = 1
1 ^ 1 = 0

面试题：交换两个变量的值（不借助第三个变量）
int a = 1;
int b = 2;

a = a ^ b;
b = a ^ b;
a = a ^ b;    
```

### 位移运算

#### 1、原码

| 十进制 | 二进制 |
| ---- | ---- |
| 2 | 00000000 00000000 00000000 00000010|
| -2 | 10000000 00000000 00000000 00000010|

二进制第1位，0 表示 正数，1 表示 负数

#### 2、反码

| 十进制 | 原码 | 反码 |
| ---- | ---- | ---- |
| 2 | 00000000 00000000 00000000 00000010 | 00000000 00000000 00000000 00000010 | 
| -2 | 10000000 00000000 00000000 00000010| 11111111 11111111 11111111 11111101 |

正数的反码和原码一样
负数的反码是在原码的基础上，保持符号位不变，其他位取反

#### 3、补码

| 十进制 | 原码 | 反码 | 补码 |
| ---- | ---- | ---- | ---- |
| 2 | 00000000 00000000 00000000 00000010 | 00000000 00000000 00000000 00000010 | 00000000 00000000 00000000 00000010 |
| -2 | 10000000 00000000 00000000 00000010| 11111111 11111111 11111111 11111101 | 11111111 11111111 11111111 11111110 |

正数的反码、原码、补码 一样
负数的补码 是 反码 + 1

```
5-3
= 5 + (-3)
= 0000 0101 + 1111 1101 // 补码相加
= 0000 0010 // 补码
= 0000 0010 // 原码
= 2 // 十进制
```

#### 4、左移(<<)

左位移运算，向左边进行位运算

简单点讲就是把十进制的数值转换成二进制，然后最高位向左移动，或者理解为2乘以数值次数

```
左移2位

十进制 10 << 2
二进制 1010 << 2
结果：
二进制 101000
十进制 40

-2 << 1
原码 10000000 00000000 00000000 00000010
反码 11111111 11111111 11111111 11111101
补码 11111111 11111111 11111111 11111110
补码左移一位 11111111 11111111 11111111 11111100
反码 11111111 11111111 11111111 11111011 // 补码减1
原码 10000000 00000000 00000000 00000100 // 反码取反
十进制 -4  
```

#### 5、右移(>>)

右位移运算，向右边进行位运算，如果最后一位为1也会舍去

简单点讲就是把十进制的数值转换成二进制，然后从最高位开始向右移动
或者理解为2除以数值次数并向下取整，如 5 / 2 等于 2.5但是向下取整最后的结果会舍掉 0.5 所以结果为2

```
右移两位

十进制 5 >> 2
二进制 1001 >> 2
结果：
二进制 0010
十进制 2
```

#### 6、无符号位移( <<< 或 >>>)

上面的左移及右移，对补码进行移动时，符号位是固定不动的。而无符号位移是指在进行位移时，符号位也跟着移动。

```
-2 >>> 1
原码 10000000 00000000 00000000 00000010
反码 11111111 11111111 11111111 11111101
补码 11111111 11111111 11111111 11111110
无符号右移 01111111 11111111 11111111 11111111 // 符号位为0
结果的原码、反码、补码 都一样，都是 01111111 11111111 11111111 11111111
十进制 2147483647
```
