### OOP约束
1. 避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接 **类名.变量/方法** 方式访问即可。
2. 相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object。可变参数必须放在参数列表最后，尽量不使用可变参数。
3. Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。eg: "test".equals(a)。
4. 所有相同类型的包装类对象之间的比较，全部使用equals方法比较。Integer a = ？，在-128 至 127范围内的赋值，Integer对象是在IntegerCache.cache产生，会复用已有对象，这个区间内的Integer值可以直接使用==进行判断，区间之外的数据，都在堆上产生，不会复用已有对象，推荐使用equals方法比较。
5. 关于基本数据类型与包装数据类型的使用标准
   * 所有POJO类属性必须使用包装数据类型
   * RPC方法的返回值和参数必须使用包装数据类型
   * 所有的局部变量使用基本数据类型
6. 定义DO、DTO、VO等POJO类时，不要设定任何属性默认值
7. 序列化类新增属性时，不要修改serialVersionUID字段，避免反序列化失败；如果完全不兼容升级，避免反序列化混乱，请修改serialVersionUID
8. 构造方法禁止加入任何业务逻辑，如有初始化逻辑，放在init方法中。
9. POJO类必须写toString方法。方便打印排查问题。
10. 当一个类有多个构造方法，或者多个同名方法，应按顺序放在一起，便于阅读
11. 类内方法定义顺序：公有或保护方法 > 私有方法 > getter/setter方法
12. getter/setter方法中，不要增加业务逻辑，会增加排查问题的复杂度
13. 循环体内，字符串的连接方式，使用StringBuilder的append方法进行扩展。如果是用 + ，反编译出的字节码文件显示每次循环都会new一个StringBuilder对象，然后进行append操作，最有通过toString方法返回String对象，造成内存浪费
14. 慎用Object的clone方法来拷贝对象，默认是浅拷贝，想实现深拷贝需要重写clone方法


### 集合约束
1. 使用工具类Arrays.asList()把数组转换成集合时，不能使用其修改集合的相关方法，add、remove、clear会抛异常
2. 不要在foreach里进行remove、add操作，要操作使用Iterator方式
3. 使用entrySet遍历Map类集合kv，而不是KeySet方式遍历。KeySet遍历了两次
4. 利用Set元素唯一的特性，可以快速对一个集合进行去重操作，避免使用List的contains方法进行遍历、对比、去重操作
   
### 并发处理


### 控制语句
1. 在 if/else/for/while/do 语句中必须使用大括号。即使只有一行代码，避免采用单行的编码方式：if (condition) statements;
2. 表达异常的分支时，少用 if-else 方式，这种方式可以改写成：
```
if (condition) { 
...
return obj; 
} 
// 接着写 else 的业务逻辑代码; 
```
说明：如果非得使用 if()...else if()...else...方式表达逻辑，【强制】避免后续代码维护困难，请勿超过 3 层。
3. 除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。
4. 循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的 try-catch 操作（这个 try-catch 是否可以移至循环体外）。

### 注释规约
1. 对于注释的要求：第一、能够准确反应设计思想和代码逻辑；第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看的，使其能够快速接替自己的工作。

### 其他
1. 注意 Math.random() 这个方法返回是 double 类型，注意取值的范围 0≤x<1（能够取到零值，注意除零异常），如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后取整，直接使用 Random 对象的 nextInt 或者 nextLong 方法。

### 异常处理
1. 对大段代码进行 try-catch，这是不负责任的表现。catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理
2. 不能在 finally 块中使用 return，finally 块中的 return 返回后方法结束执行，不会再执行 try 块中的 return 语句。
3. 防止 NPE，是程序员的基本修养，注意 NPE 产生的场景：
   * 返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE。
   反例：public int f() { return Integer 对象}， 如果为 null，自动解箱抛 NPE。
   * 数据库的查询结果可能为 null。 3） 集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。 4） 远程调用返回对象时，一律要求进行空指针判断，防止 NPE。 5） 对于 Session 中获取的数据，建议 NPE 检查，避免空指针。
   * 级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE。
   正例：使用 JDK8 的 Optional 类来防止 NPE 问题。
4. 在代码中使用“抛异常”还是“返回错误码”，对于公司外的 http/api 开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间 RPC 调用优先考虑使用 Result 方式，封装 isSuccess()方法、“错误码”、“错误简短信息”。
说明：关于 RPC 方法返回方式使用 Result 方式的理由：
   * 使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。
   * 如果不加栈信息，只是 new 自定义异常，加入自己的理解的 error message，对于调用端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题。
5. 异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字 throws 往上抛出。