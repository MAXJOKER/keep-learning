### OOP约束
1. 避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接 **类名.变量/方法** 方式访问即可。
2. 相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object。可变参数必须放在参数列表最后，尽量不使用可变参数。
3. Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。eg: "test".equals(a)。
4. 所有相同类型的包装类对象之间的比较，全部使用equals方法比较。Integer a = ？，在-128 至 127范围内的赋值，Integer对象是在IntegerCache.cache产生，会复用已有对象，这个区间内的Integer值可以直接使用==进行判断，区间之外的数据，都在堆上产生，不会复用已有对象，推荐使用equals方法比较。
5. 关于基本数据类型与包装数据类型的使用标准
   * 所有POJO类属性必须使用包装数据类型
   * RPC方法的返回值和参数必须使用包装数据类型
   * 所有的局部变量使用基本数据类型
6. 定义DO、DTO、VO等POJO类时，不要设定任何属性默认值
7. 序列化类新增属性时，不要修改serialVersionUID字段，避免反序列化失败；如果完全不兼容升级，避免反序列化混乱，请修改serialVersionUID
8. 构造方法禁止加入任何业务逻辑，如有初始化逻辑，放在init方法中。
9. POJO类必须写toString方法。方便打印排查问题。
10. 当一个类有多个构造方法，或者多个同名方法，应按顺序放在一起，便于阅读
11. 类内方法定义顺序：公有或保护方法 > 私有方法 > getter/setter方法
12. getter/setter方法中，不要增加业务逻辑，会增加排查问题的复杂度
13. 循环体内，字符串的连接方式，使用StringBuilder的append方法进行扩展。如果是用 + ，反编译出的字节码文件显示每次循环都会new一个StringBuilder对象，然后进行append操作，最有通过toString方法返回String对象，造成内存浪费
14. 慎用Object的clone方法来拷贝对象，默认是浅拷贝，想实现深拷贝需要重写clone方法


### 集合约束
1. 使用工具类Arrays.asList()把数组转换成集合时，不能使用其修改集合的相关方法，add、remove、clear会抛异常
2. 不要在foreach里进行remove、add操作，要操作使用Iterator方式
3. 使用entrySet遍历Map类集合kv，而不是KeySet方式遍历。KeySet遍历了两次
4. 利用Set元素唯一的特性，可以快速对一个集合进行去重操作，避免使用List的contains方法进行遍历、对比、去重操作
   
### 并发处理


### 控制语句
1. 在 if/else/for/while/do 语句中必须使用大括号。即使只有一行代码，避免采用单行的编码方式：if (condition) statements;
2. 表达异常的分支时，少用 if-else 方式，这种方式可以改写成：
```
if (condition) { 
...
return obj; 
} 
// 接着写 else 的业务逻辑代码; 
```
说明：如果非得使用 if()...else if()...else...方式表达逻辑，【强制】避免后续代码维护困难，请勿超过 3 层。
3. 除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。
4. 循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的 try-catch 操作（这个 try-catch 是否可以移至循环体外）。

### 注释规约
1. 对于注释的要求：第一、能够准确反应设计思想和代码逻辑；第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看的，使其能够快速接替自己的工作。

### 其他
1. 注意 Math.random() 这个方法返回是 double 类型，注意取值的范围 0≤x<1（能够取到零值，注意除零异常），如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后取整，直接使用 Random 对象的 nextInt 或者 nextLong 方法。

### 异常处理
1. 对大段代码进行 try-catch，这是不负责任的表现。catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理
2. 不能在 finally 块中使用 return，finally 块中的 return 返回后方法结束执行，不会再执行 try 块中的 return 语句。
3. 防止 NPE，是程序员的基本修养，注意 NPE 产生的场景：
   * 返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE。
   反例：public int f() { return Integer 对象}， 如果为 null，自动解箱抛 NPE。
   * 数据库的查询结果可能为 null。 3） 集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。 4） 远程调用返回对象时，一律要求进行空指针判断，防止 NPE。 5） 对于 Session 中获取的数据，建议 NPE 检查，避免空指针。
   * 级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE。
   正例：使用 JDK8 的 Optional 类来防止 NPE 问题。
4. 在代码中使用“抛异常”还是“返回错误码”，对于公司外的 http/api 开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间 RPC 调用优先考虑使用 Result 方式，封装 isSuccess()方法、“错误码”、“错误简短信息”。
说明：关于 RPC 方法返回方式使用 Result 方式的理由：
   * 使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。
   * 如果不加栈信息，只是 new 自定义异常，加入自己的理解的 error message，对于调用端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题。
5. 异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字 throws 往上抛出。

### 单元测试
1. 好的单元测试必须遵守AIR原则，A：automatic 自动化，I：independent 独立性，R：repeatable 可重复
2. 单元测试应该是全自动执行的，并且非交互式的。测试用例通常是被定期执行的，执行过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个好的单元测试。单元测试中不准使用 System.out 来进行人肉验证，必须使用 assert 来验证。
3. 保持单元测试的独立性。为了保证单元测试稳定可靠且便于维护，单元测试用例之间决不能互相调用，也不能依赖执行的先后次序。
4. 单元测试是可以重复执行的，不能受到外界环境的影响。
   说明：单元测试通常会被放到持续集成中，每次有代码 check in 时单元测试都会被执行。如果单测对外部环境（网络、服务、中间件等）有依赖，容易导致持续集成机制的不可用。
   正例：为了不受外界环境影响，要求设计代码时就把 SUT 的依赖改成注入，在测试时用 spring这样的 DI 框架注入一个本地（内存）实现或者 Mock 实现。
5. 对于单元测试，要保证测试粒度足够小，有助于精确定位问题。单测粒度至多是类级别，一般是方法级别。
6. 单元测试的基本目标：语句覆盖率达到 70%；核心模块的语句覆盖率和分支覆盖率都要达到 100%
7. 编写单元测试代码遵守 BCDE 原则，以保证被测试模块的交付质量。
   * B：Border，边界值测试，包括循环边界、特殊取值、特殊时间点、数据顺序等。
   * C：Correct，正确的输入，并得到预期的结果。
   * D：Design，与设计文档相结合，来编写单元测试。
   * E：Error，强制错误信息输入（如：非法数据、异常流程、非业务允许输入等），并得到预期的结果。
8. 对于数据库相关的查询，更新，删除等操作，不能假设数据库里的数据是存在的，或者直接操作数据库把数据插入进去，请使用程序插入或者导入数据的方式来准备数据。

### 数据库 - 建表规约
1. 表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（1 表示是，0 表示否），任何字段如果是非负，必须是unsigned
2. 表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。
3. 表名不使用复数名词。
4. 主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名
5. 小数类型为 decimal，禁止使用 float 和 double。
6. 如果存储的字符串长度几乎相等，使用 char 定长字符串类型。
7. varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，**定义字段类型为 text**，独立出来一张表，用主键来对应，避免影响其它字段索引效率。
8. 字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：
   * 不是频繁修改的字段。
   * 不是 varchar 超长字段，更不能是 text 字段。
9. 单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。

### 数据库 - 索引规约
1. 业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。
   说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生
2. 超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。
3. 在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。 // todo 不太理解
   说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90%以上，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定。
4. 页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。
   说明：索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。
5. 如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。
   ```
   正例：where a=? and b=? order by c; 索引：a_b_c
   反例：索引中有范围查找，那么索引有序性无法利用，如：WHERE a>10 ORDER BY b; 索引a_b 无法排序。   
   ```
6. 利用覆盖索引来进行查询操作，避免回表。
   正例：能够建立索引的种类分为主键索引、唯一索引、普通索引三种，而覆盖索引只是一种查询的一种效果，用 explain 的结果，extra 列会出现：using index。
7. 利用延迟关联或者子查询优化超多分页场景。
   说明：MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写。
   正例：先快速定位需要获取的 id 段，然后再关联：
   SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id
8. SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是 consts最好。 
   * consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。
   * ref 指的是使用普通的索引（normal index）。
   * range 对索引进行范围检索。
9. 建组合索引的时候，区分度最高的在最左边。
10. 防止因字段类型不同造成的隐式转换，导致索引失效。

### 数据库 - sql语句
1. 不要使用 count(列名)或 count(常量)来替代 count(*)，count(*)是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。
   说明：count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。
2. 禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。
3. 数据订正（特别是删除、修改记录操作）时，要先 select，避免出现误删除，确认无误才能执行更新语句。
4. in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控制在 1000 个之内。
5. 在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。
   说明：1）增加查询分析器解析成本。2）增减字段容易与 resultMap 配置不一致。3）无用字段增加网络消耗，尤其是 text 类型的字段。
6. sql.xml 配置参数使用：#{}，#param# 不要使用${} 此种方式容易出现 SQL 注入。
7. iBATIS 自带的 queryForList(String statementName,int start,int size)不推荐使用。其实现方式是在数据库取到 statementName对应的SQL语句的所有记录，再通过 subList取 start,size 的子集合。
8. 不要写一个大而全的数据更新接口。传入为 POJO 类，不管是不是自己的目标更新字段，都进行 update table set c1=value1,c2=value2,c3=value3; 这是不对的。执行 SQL时，不要更新无改动的字段，一是易出错；二是效率低；三是增加 binlog 存储。

### 工程结构
1. 分层领域模型规约：
   * DO（Data Object）：此对象与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。
   * DTO（Data Transfer Object）：数据传输对象，Service 或 Manager 向外传输的对象。
   * BO（Business Object）：业务对象，由 Service 层输出的封装业务逻辑的对象。
   * AO（Application Object）：应用对象，在 Web 层与 Service 层之间抽象的复用对象模型，极为贴近展示层，复用度不高。
   * VO（View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。
   * Query：数据查询对象，各层接收上层的查询请求。注意超过 2 个参数的查询封装，禁止使用 Map 类来传输。

### 服务器
1. 高并发服务器建议调小 TCP 协议的 time_wait 超时时间。
   说明：操作系统默认 240 秒后，才会关闭处于 time_wait 状态的连接，在高并发访问下，服务器端会因为处于 time_wait 的连接数太多，可能无法建立新的连接，所以需要在服务器上调小此等待值。
   正例：在 linux 服务器上请通过变更/etc/sysctl.conf 文件去修改该缺省值（秒）：
   net.ipv4.tcp_fin_timeout = 30
2. 调大服务器所支持的最大文件句柄数（File Descriptor，简写为 fd）。
   说明：主流操作系统的设计是将 TCP/UDP 连接采用与文件一样的方式去管理，即一个连接对应于一个 fd。主流的 linux 服务器默认所支持最大 fd 数量为 1024，当并发连接数很大时很容易因为 fd 不足而出现“open too many files”错误，导致新的连接无法建立。 建议将 linux服务器所支持的最大句柄数调高数倍（与服务器的内存数量相关）。
3. 给 JVM 设置-XX:+HeapDumpOnOutOfMemoryError 参数，让 JVM 碰到 OOM 场景时输出dump 信息。
4. 在线上生产环境，JVM 的 Xms 和 Xmx 设置一样大小的内存容量，避免在 GC 后调整堆大小带来的压力。
5. 服务器内部重定向使用 forward；外部重定向地址使用 URL 拼装工具类来生成，否则会带来 URL 维护不一致的问题和潜在的安全风险。